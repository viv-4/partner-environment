#! /usr/bin/env bash

banner() {
    echo
    echo '░░░░░░░\  ░░\                                ░░░░░░\   ░░░░░░\'
    echo '░░  __░░\ ░░ |                              ░░  __░░\ ░░  __░░\'
    echo '░░ |  ░░ |░░ | ░░░░░░\   ░░░░░░░\  ░░░░░░\  ░░ /  ░░ |░░ /  \__|'
    echo '░░░░░░░  |░░ | \____░░\ ░░  _____|░░  __░░\ ░░ |  ░░ |\░░░░░░\'
    echo '░░  ____/ ░░ | ░░░░░░░ |░░ /      ░░░░░░░░ |░░ |  ░░ | \____░░\'
    echo '░░ |      ░░ |░░  __░░ |░░ |      ░░   ____|░░ |  ░░ |░░\   ░░ |'
    echo '░░ |      ░░ |\░░░░░░░ |\░░░░░░░\ \░░░░░░░\  ░░░░░░  |\░░░░░░  |'
    echo '\__|      \__| \_______| \_______| \_______| \______/  \______/'
    echo
}

# The bash hail mary (exit on failure, unset variables, fail pipe composition early)
set -euo pipefail

# Kill child processes on signals
trap 'tput cnorm; pkill -P $$;' SIGINT SIGTERM

# Colours
red='\033[0;31m'
green='\033[0;32m'
reset='\033[0m'

# Whether to write to STDOUT or not
VERBOSE="false"

# Path of directory containing the script
base_path="$(dirname "${0}")"

# Terminal spinner
source "${base_path}/scripts/spinner.sh"

# Create a logfile
mkdir -p "${base_path}/.logs"
logfile="${base_path}/.logs/$(date +"%Y%m%d%H%M").log"

COMPOSE_PROJECT_NAME=placeos

abort() {
    echo -e "░░░ ${red}${1}${reset}"
    echo "░░░ Logs can be found in ${logfile}"
    exit 1
}

run_or_abort() {
    task="${1}"
    start="${2}"
    failure="${3}"
    ignore_failure="${4-"false"}"

    # Hacks to ensure env is forwarded. It's unclear as to why this isn't done by default
    env=$(printenv | awk 'BEGIN {FS=OFS="="} { print $1, "\""$2"\"" }' | tr '\n' ';')

    exit_code="0"
    if [ "${VERBOSE}" == "false" ]; then
        start_spinner "░░░ ${start}"
        eval "${env} ${task} >>${logfile} 2>&1" || exit_code="$?"
        stop_spinner $exit_code
    else
        echo "░░░ ${start}"
        eval "${env} ${task} 2>&1 | tee -a ${logfile}" || exit_code="$?"
    fi

    if [ $ignore_failure != "true" ]; then
        [ $exit_code -eq "0" ] || abort "${failure:-"${task} failed with ${exit_code}"}"
    fi
}

hard_reset() {
    # TODO: drop influxdb tables
    # TODO: clear redis

    run_or_abort \
        "${base_path}/scripts/run-sam-task drop:db" \
        "Dropping RethinkDB tables..." \
        "Failed to drop RethinkDB tables."

    run_or_abort \
        "${base_path}/scripts/run-sam-task drop:elastic" \
        "Dropping Elasticsearch indices..." \
        "Failed to drop Elasticsearch indices."

    run_or_abort \
        'docker-compose restart nginx' \
        "Restarting nginx..." \
        "Failed to restart nginx."
}

start_environment__usage() {
    cat <<EOF
Usage: ./placeos start [-h|--help]

Start the PlaceOS environment

Arguments:
    --hard-reset            Reset the environment to a default state.
    --email EMAIL           Email to setup an admin account for. [default: support@place.tech]
    --password PASSWORD     Password for created admin account. [default: development]
    --domain DOMAIN         Domain to configure. [default: localhost:8443]
    --application APP       Application to configure. [default: backoffice]
    -s, --sentry            Set-up Sentry.
    -v, --verbose           Write logs to STDOUT in addition to the log file.
    -h, --help              Display this message.
EOF
}

start_environment() {
    SERVICES=('')
    hard_reset=false
    setup_sentry=false
    email_argument=""
    password_argument=""
    domain_argument=""
    application_argument=""
    while [ ${#} -gt 0 ]; do
        command="${1}"
        shift
        case ${command} in
        --hard-reset)
            read -rp "░░░ $(echo -e "${red}Warning:${reset}") This will reset your environment. Would you like to continue (y/n)? " choice
            case "${choice}" in
            y | Y | YES | yes)
                hard_reset=true
                ;;
            *)
                abort "Exiting."
                ;;
            esac
            ;;
        --email)
            email_argument="${1}"
            shift
            ;;
        --password)
            password_argument="${1}"
            shift
            ;;
        --domain)
            domain_argument="${1}"
            shift
            ;;
        --application)
            application_arguement="${1}"
            shift
            ;;
        -s | --sentry)
            setup_sentry=true
            SERVICES+=('-s')
            ;;
        -v | --verbose)
            VERBOSE="true"
            ;;
        -h | --help | help)
            start_environment__usage
            exit 0
            ;;
        *)
            if [ -n "${command}" ]; then
                echo -e "░░░ ${red}Unknown option:${reset} ${command}"
            else
                start_environment__usage
                exit 1
            fi
            ;;
        esac
    done

    banner

    # We cannot do substition with defaults in the .env
    EXISTING_PLACEOS_TAG=${PLACEOS_TAG:-""}
    EXISTING_PLACE_APPLICATION=${PLACE_APPLICATION:-""}
    EXISTING_PLACE_DOMAIN=${PLACE_DOMAIN:-""}
    EXISTING_PLACE_EMAIL=${PLACE_EMAIL:-""}
    EXISTING_PLACE_PASSWORD=${PLACE_PASSWORD:-""}
    EXISTING_PLACE_USERNAME=${PLACE_USERNAME:-""}

    PLACEOS_TAG=${EXISTING_PLACEOS_TAG}
    PLACE_APPLICATION=${EXISTING_PLACE_APPLICATION}
    PLACE_DOMAIN=${EXISTING_PLACE_DOMAIN}
    PLACE_EMAIL=${EXISTING_PLACE_EMAIL}
    PLACE_PASSWORD=${EXISTING_PLACE_PASSWORD}
    PLACE_USERNAME=${EXISTING_PLACE_USERNAME}

    # Import environment
    set -o allexport
    source "${base_path}/.env"
    set +o allexport

    # Restore existing environment unless empty
    PLACEOS_TAG=${EXISTING_PLACEOS_TAG:-$PLACEOS_TAG}
    PLACE_APPLICATION=${EXISTING_PLACE_APPLICATION:-$PLACE_APPLICATION}
    PLACE_DOMAIN=${EXISTING_PLACE_DOMAIN:-$PLACE_DOMAIN}
    PLACE_EMAIL=${EXISTING_PLACE_EMAIL:-$PLACE_EMAIL}
    PLACE_PASSWORD=${EXISTING_PLACE_PASSWORD:-$PLACE_PASSWORD}
    PLACE_USERNAME=${EXISTING_PLACE_USERNAME:-$PLACE_USERNAME}

    echo "░░░ Starting PlaceOS <${PLACEOS_TAG}>"
    [ $VERBOSE == "false" ] && echo "░░░ For detailed logging, run \`tail -f ${logfile}\`"

    EMAIL_ENV="${base_path}/.env.email"

    set -a
    if [ -f "${EMAIL_ENV}" ]; then
        . ${EMAIL_ENV}
    elif [ -n "${email_argument}" ]; then
        # Override env with CLI arguments
        PLACE_EMAIL=${email_argument}
        # Write the email so as to not prompt the user again.
        echo "PLACE_EMAIL=${PLACE_EMAIL}" >${EMAIL_ENV}
    fi
    set +a

    # Override .env arguments with CLI arguments

    if [ -n "${password_argument}" ]; then
        PLACE_PASSWORD=${password_argument}
    fi

    if [ -n "${domain_argument}" ]; then
        PLACE_DOMAIN=${domain_argument}
    fi

    if [ -n "${application_argument}" ]; then
        PLACE_APPLICATION=${application_argument}
    fi

    # Attempt to set the username to that in git config if username not in env
    if [ -z "${PLACE_USERNAME}" ]; then
        PLACE_USERNAME=${PLACE_USERNAME:-"$(git config user.name 2>/dev/null || exit 0)"}
        PLACE_USERNAME=${PLACE_USERNAME:-"Place Support"}
    fi

    # Prompt the user for their email if not already set via `.env` or argument
    if [ -z "${PLACE_EMAIL}" ]; then
        PLACE_EMAIL=${PLACE_EMAIL:-"$(git config user.email 2>/dev/null || exit 0)"}
        PLACE_EMAIL=${PLACE_EMAIL:-"support@place.tech"}

        read -rp "░░░ Please enter an email ($(echo -e "${green}default:${reset}") ${PLACE_EMAIL}): " choice
        if [ -n "${choice}" ]; then
            PLACE_EMAIL=${choice}
        fi
    fi

    # Prompt the user for their password if not already set via `.env`
    # TODO: Check for the user before asking for a password
    # TODO: Autogenerate the default password
    while [ -z "${PLACE_PASSWORD}" ]; do
        read -srp "░░░ Please enter a password: " choice
        PLACE_PASSWORD="${choice}"
        # Newline after response
        echo ""
    done

    # run_or_abort \
    #     "${base_path}/scripts/metricbeat" \
    #     "Checking Host OS..." \
    #     "Error occurred while checking Host OS."

    run_or_abort \
        "${base_path}/scripts/generate-secrets" \
        "Generating secrets..." \
        "Failed to generate secrets."

    # Write the email so as to not prompt the user again.
    echo "PLACE_EMAIL=${PLACE_EMAIL}" >${EMAIL_ENV}
    # TODO: use init check instead of writing the password.
    echo "PLACE_PASSWORD=${PLACE_PASSWORD}" >>${EMAIL_ENV}

    run_or_abort \
        "${base_path}/scripts/start-services ${SERVICES[@]}" \
        "Bringing up services..." \
        "Failed to start services."

    run_or_abort \
        "${base_path}/scripts/init-influxdb" \
        "Configuring InfluxDB..." \
        "Failed to configure InfluxDB."

    if [[ $setup_sentry == "true" ]]; then
        run_or_abort \
            "${base_path}/scripts/setup-sentry.sh" \
            "Setting up sentry..." \
            "Failed to setup sentry"

        echo "░░░ Sentry setup complete. Login to http://$PLACE_DOMAIN on port 8989 with..."
        echo "░░░ ${PLACE_EMAIL}:${PLACE_PASSWORD}"
    else
        echo "░░░ To setup Sentry, run \`${base_path}/placeos start -s\`"
    fi

    [ ${hard_reset} == "true" ] && hard_reset

    run_or_abort \
        "${base_path}/scripts/run-init-container" \
        "Initialising PlaceOS with default domain ($PLACE_DOMAIN)..." \
        "Failed to create user entity."

    echo "░░░ PlaceOS initialised. Login to https://$PLACE_DOMAIN/backoffice/ with..."
    echo "░░░ $PLACE_EMAIL:$PLACE_PASSWORD"
}

stop_environment__usage() {
    cat <<EOF
Usage: ./placeos stop [-h|--help]

Stop the PlaceOS environment

Arguments:
    -h, --help              Display this message
EOF
}

stop_environment() {
    while [ ${#} -gt 0 ]; do
        command="${1}"
        shift
        case ${command} in
        -h | --help | help)
            stop_environment__usage
            exit 0
            ;;
        *)
            if [ -n "${command}" ]; then
                echo -e "░░░ ${red}Unknown option:${reset} ${command}"
            else
                stop_environment__usage
                exit 1
            fi
            ;;
        esac
    done

    run_or_abort \
        "docker-compose down" \
        "Tearing down PlaceOS" \
        "Failed to teardown PlaceOS"
}

update_environment__usage() {
    cat <<EOF
Usage: ./placeos update [-h|--help]

Update the PlaceOS environment

Arguments:
    -h, --help              Display this message
EOF
}

update_environment() {
    while [ ${#} -gt 0 ]; do
        command="${1}"
        shift
        case ${command} in
        -h | --help | help)
            update_environment__usage
            exit 0
            ;;
        *)
            if [ -n "${command}" ]; then
                echo -e "░░░ ${red}Unknown option:${reset} ${command}"
            else
                update_environment__usage
                exit 1
            fi
            ;;
        esac
    done

    # The basic idea is that the script should not need git...
    # Users will be able to to the next patch, or minor version
    # Version info can be extracted from the heads of version branches in a file containing the version
    abort "Not implemented."
}

usage() {
    cat <<EOF
Usage: ./placeos [-h|--help] [command]

Helper script for interfacing with the PlaceOS Partner Environment

Command:
    start                   Start the environment.
    stop                    Stops the environment.
    help                    Display this message.

Arguments:
    -h, --help              Display this message.
EOF
}

if [ $# -eq 0 ]; then
    usage
    exit 1
fi

command="$1"
shift
case $command in
start)
    start_environment "$@"
    ;;
stop)
    stop_environment "$@"
    ;;
update)
    update_environment "$@"
    ;;
-h | --help | help)
    usage
    ;;
*)
    if [ -n "$command" ]; then
        echo -e "░░░ ${red}Unknown command:${reset} $command"
    else
        usage
        exit 1
    fi
    ;;
esac
